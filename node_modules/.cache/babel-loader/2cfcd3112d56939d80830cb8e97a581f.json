{"ast":null,"code":"'use strict';\n/* eslint max-depth: [\"error\", 4] */\n\nvar sameOrigin = require('same-origin');\n\nvar parseHeaders = require('parse-headers');\n\nvar noop = function noop() {\n  /* intentional noop */\n};\n\nvar win = window;\nvar XmlHttpRequest = win.XMLHttpRequest || noop;\nvar hasXhr2 = ('withCredentials' in new XmlHttpRequest());\nvar XDomainRequest = hasXhr2 ? XmlHttpRequest : win.XDomainRequest;\nvar adapter = 'xhr';\n\nmodule.exports = function (context, callback) {\n  var opts = context.options;\n  var options = context.applyMiddleware('finalizeOptions', opts);\n  var timers = {}; // Deep-checking window.location because of react native, where `location` doesn't exist\n\n  var cors = win && win.location && !sameOrigin(win.location.href, options.url); // Allow middleware to inject a response, for instance in the case of caching or mocking\n\n  var injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter: adapter,\n    context: context\n  }); // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n\n  if (injectedResponse) {\n    var cbTimer = setTimeout(callback, 0, null, injectedResponse);\n\n    var cancel = function cancel() {\n      return clearTimeout(cbTimer);\n    };\n\n    return {\n      abort: cancel\n    };\n  } // We'll want to null out the request on success/failure\n\n\n  var xhr = cors ? new XDomainRequest() : new XmlHttpRequest();\n  var isXdr = win.XDomainRequest && xhr instanceof win.XDomainRequest;\n  var headers = options.headers; // Request state\n\n  var aborted = false;\n  var loaded = false;\n  var timedOut = false; // Apply event handlers\n\n  xhr.onerror = onError;\n  xhr.ontimeout = onError;\n\n  xhr.onabort = function () {\n    aborted = true;\n  }; // IE9 must have onprogress be set to a unique function\n\n\n  xhr.onprogress = function () {\n    /* intentional noop */\n  };\n\n  var loadEvent = isXdr ? 'onload' : 'onreadystatechange';\n\n  xhr[loadEvent] = function () {\n    // Prevent request from timing out\n    resetTimers();\n\n    if (aborted || xhr.readyState !== 4 && !isXdr) {\n      return;\n    } // Will be handled by onError\n\n\n    if (xhr.status === 0) {\n      return;\n    }\n\n    onLoad();\n  }; // @todo two last options to open() is username/password\n\n\n  xhr.open(options.method, options.url, true // Always async\n  ); // Some options need to be applied after open\n\n  xhr.withCredentials = !!options.withCredentials; // Set headers\n\n  if (headers && xhr.setRequestHeader) {\n    for (var key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  } else if (headers && isXdr) {\n    throw new Error('Headers cannot be set on an XDomainRequest object');\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer';\n  } // Let middleware know we're about to do a request\n\n\n  context.applyMiddleware('onRequest', {\n    options: options,\n    adapter: adapter,\n    request: xhr,\n    context: context\n  });\n  xhr.send(options.body || null); // Figure out which timeouts to use (if any)\n\n  var delays = options.timeout;\n\n  if (delays) {\n    timers.connect = setTimeout(function () {\n      return timeoutRequest('ETIMEDOUT');\n    }, delays.connect);\n  }\n\n  return {\n    abort: abort\n  };\n\n  function abort() {\n    aborted = true;\n\n    if (xhr) {\n      xhr.abort();\n    }\n  }\n\n  function timeoutRequest(code) {\n    timedOut = true;\n    xhr.abort();\n    var error = new Error(code === 'ESOCKETTIMEDOUT' ? 'Socket timed out on request to ' + options.url : 'Connection timed out on request to ' + options.url);\n    error.code = code;\n    context.channels.error.publish(error);\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return;\n    }\n\n    stopTimers();\n    timers.socket = setTimeout(function () {\n      return timeoutRequest('ESOCKETTIMEDOUT');\n    }, delays.socket);\n  }\n\n  function stopTimers() {\n    // Only clear the connect timeout if we've got a connection\n    if (aborted || xhr.readyState >= 2 && timers.connect) {\n      clearTimeout(timers.connect);\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket);\n    }\n  }\n\n  function onError() {\n    if (loaded) {\n      return;\n    } // Clean up\n\n\n    stopTimers();\n    loaded = true;\n    xhr = null; // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n\n    var err = new Error('Network error while attempting to reach ' + options.url);\n    err.isNetworkError = true;\n    err.request = options;\n    callback(err);\n  }\n\n  function reduceResponse() {\n    var statusCode = xhr.status;\n    var statusMessage = xhr.statusText;\n\n    if (isXdr && statusCode === undefined) {\n      // IE8 CORS GET successful response doesn't have a status field, but body is fine\n      statusCode = 200;\n    } else if (statusCode > 12000 && statusCode < 12156) {\n      // Yet another IE quirk where it emits weird status codes on network errors\n      // https://support.microsoft.com/en-us/kb/193625\n      return onError();\n    } else {\n      // Another IE bug where HTTP 204 somehow ends up as 1223\n      statusCode = xhr.status === 1223 ? 204 : xhr.status;\n      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage;\n    }\n\n    return {\n      body: xhr.response || xhr.responseText,\n      url: options.url,\n      method: options.method,\n      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: statusCode,\n      statusMessage: statusMessage\n    };\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return;\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'));\n      return;\n    } // Prevent being called twice\n\n\n    stopTimers();\n    loaded = true;\n    callback(null, reduceResponse());\n  }\n};","map":{"version":3,"mappings":"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","names":["sameOrigin","require","parseHeaders","noop","win","window","XmlHttpRequest","XMLHttpRequest","hasXhr2","XDomainRequest","adapter","module","exports","context","callback","opts","options","applyMiddleware","timers","cors","location","href","url","injectedResponse","undefined","cbTimer","setTimeout","cancel","clearTimeout","abort","xhr","isXdr","headers","aborted","loaded","timedOut","onerror","onError","ontimeout","onabort","onprogress","loadEvent","resetTimers","readyState","status","onLoad","open","method","withCredentials","setRequestHeader","key","hasOwnProperty","Error","rawBody","responseType","request","send","body","delays","timeout","connect","timeoutRequest","code","error","channels","publish","stopTimers","socket","err","isNetworkError","reduceResponse","statusCode","statusMessage","statusText","response","responseText","getAllResponseHeaders"],"sources":["../../src/request/browser-request.js"],"sourcesContent":["/* eslint max-depth: [\"error\", 4] */\nconst sameOrigin = require('same-origin')\nconst parseHeaders = require('parse-headers')\nconst noop = function() {\n  /* intentional noop */\n}\n\nconst win = window\nconst XmlHttpRequest = win.XMLHttpRequest || noop\nconst hasXhr2 = 'withCredentials' in new XmlHttpRequest()\nconst XDomainRequest = hasXhr2 ? XmlHttpRequest : win.XDomainRequest\nconst adapter = 'xhr'\n\nmodule.exports = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts)\n  const timers = {}\n\n  // Deep-checking window.location because of react native, where `location` doesn't exist\n  const cors = win && win.location && !sameOrigin(win.location.href, options.url)\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = cors ? new XDomainRequest() : new XmlHttpRequest()\n\n  const isXdr = win.XDomainRequest && xhr instanceof win.XDomainRequest\n  const headers = options.headers\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = onError\n  xhr.ontimeout = onError\n  xhr.onabort = () => {\n    aborted = true\n  }\n\n  // IE9 must have onprogress be set to a unique function\n  xhr.onprogress = () => {\n    /* intentional noop */\n  }\n\n  const loadEvent = isXdr ? 'onload' : 'onreadystatechange'\n  xhr[loadEvent] = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || (xhr.readyState !== 4 && !isXdr)) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method,\n    options.url,\n    true // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  } else if (headers && isXdr) {\n    throw new Error('Headers cannot be set on an XDomainRequest object')\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  const delays = options.timeout\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code) {\n    timedOut = true\n    xhr.abort()\n    const error = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers() {\n    // Only clear the connect timeout if we've got a connection\n    if (aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError() {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers()\n    loaded = true\n    xhr = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = new Error(`Network error while attempting to reach ${options.url}`)\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse() {\n    let statusCode = xhr.status\n    let statusMessage = xhr.statusText\n\n    if (isXdr && statusCode === undefined) {\n      // IE8 CORS GET successful response doesn't have a status field, but body is fine\n      statusCode = 200\n    } else if (statusCode > 12000 && statusCode < 12156) {\n      // Yet another IE quirk where it emits weird status codes on network errors\n      // https://support.microsoft.com/en-us/kb/193625\n      return onError()\n    } else {\n      // Another IE bug where HTTP 204 somehow ends up as 1223\n      statusCode = xhr.status === 1223 ? 204 : xhr.status\n      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage\n    }\n\n    return {\n      body: xhr.response || xhr.responseText,\n      url: options.url,\n      method: options.method,\n      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: statusCode,\n      statusMessage: statusMessage\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n"]},"metadata":{},"sourceType":"script"}